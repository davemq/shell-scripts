#!/bin/sh

#
# Read from standard input
# Convert hangman style expression to regular expression
# Write to standard output

# Example hangman style expression:
#
# _ _ _ _ _ _ _ _   _ _ _ _ _ ' _   _ _ _ _   _ _ _ ,   _ _ _ _ - _ _ _
#
# Each _ represents a letter. Single spaces between underscores are ignored.
# 3 or more spaces between underscores represents a space. Other characters
# are literal, and not converted.

# The generated regular expression is repetitive, with many of the
# matching character class. A more sophisticated converter would count
# the consecutive underscores and generate [${chars}]]\{count\}. A
# program generated with something like lex or flex would be helpful
# here, and maybe a parser generated by yacc or bison would be needed.

# The generated regular expression assumes matching is done with lowercase
# letters, so using the expression with tools like "grep" requires using
# the "-i" option to ignore case.

# Future additions:
#
# - Reverse: Given a phrase, generate the hangman-style expression.
#
# - adjustments to character and word spacing. The single space
#   between characters of a word and 3 or more spaces betweeen words
#   is how I like to format these phrases. But there isn't a general
#   agreement here, so it would be useful to make this tunable through
#   command line options. Also useful when generating hangman phrases
#   in the "reverse" mode (see above).
#
# - take phrase as a command line argument rather than standard input

chars="abcdefghijklmnopqrstuvwxyz"
allchars=$chars
outchars='[:alpha:]'

set -o noglob			# don't expand filename patterns

# Parse options
# -x  Remove character from chars. It only looks at the first character
#     of the option string, but you can use multiple -x options to 
#     remove multiple characters
#
# *   phrase. Assume a single option here, and break out

while [ $# -gt 0 ]
do
    case $1 in
	-x)
	    # Assume a single character
	    
	    c=${2,[A-Z]}	# convert to lower case
	    chars=${chars/$c/}	# remove
	    outchars=$chars
	    shift
	    ;;

	*)
	    phrase=$1
	    break
	    ;;
    esac
    shift
done

if [ -n "$phrase" ]
then
    REPLY="$phrase"
else
    # Read the whole phrase from standard input into REPLY
    read
fi

# Change word separators to XXX
REPLY=${REPLY//   / XXX }

# put into positional parameters
set -- $REPLY

# Scan for alphabetical characters and remove them from "chars"
while [ $# -gt 0 ]
do
    case "$1" in
	[A-Za-z])
	    c=${1,[A-Z]}	# lower case it
	    chars=${chars/$c/}	# remove it
	    outchars=$chars
	    ;;

    esac
    shift
done

set -- $REPLY
output='\<'
(( unders=0 ))
while [ $# -gt 0 ]
do
    case "$1" in 
	[A-Za-z])
	    c=${1,[A-Z]}	# lower case it
	    if ((unders > 1))
	    then
		output="${output}[${outchars}]\{${unders}\}"
	    elif (( unders == 1 ))
	    then
		 output="${output}[${outchars}]"
	    fi
	    (( unders = 0 ))
	    output="${output}${c}"
	    ;;

	_)
	    (( unders++ ))
	    ;;

	XXX)
	    if (( unders > 1 ))
	    then
		output="${output}[${outchars}]\{${unders}\}"
	    elif (( unders == 1 ))
	    then
		 output="${output}[${outchars}]"
	    fi
	    (( unders = 0 ))
	    output="${output}  *"
	    ;;
	*)
	    if (( unders > 1 ))
	    then
		output="${output}[${outchars}]\{${unders}\}"
	    elif (( unders == 1 ))
	    then
		 output="${output}[${outchars}]"
	    fi
	    (( unders = 0 ))
	    output="${output}$1"
	    ;;
	    
    esac
    shift
done
if (( unders > 1 ))
then
    output="${output}[${outchars}]\{${unders}\}"
elif (( unders == 1 ))
then
    output="${output}[${outchars}]"
fi
output="${output}\\>"

echo "$output"

# Apply updated "chars" in generating the regular expression

#echo "$REPLY" | sed -e "s/_/[${chars}]/g" -e 's/ \{3,\}/XXX/g' -e 's/ //g' -e 's/XXX/ /g'
